{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Katxupa","text":"<p>Delicious Dish for Typescript and JavaScript projects.</p> <p>In Cape Verde we have a saying:</p> <p>\"Put a person to work in the field and serve them anything other than Katxupa for breakfast, and you'll notice a decline in productivity and motivation. Therefore, give them Katxupa and spice it up on the side.\"</p> <p>Just as \"Katxupa\" is an essential part of Cape Verdean culture, this library brings functional elements to enhance your productivity and developer happiness. So, consume (use) it!</p> <p>Katxupa, Cape Verde\u2019s national dish, is a flavorful stew consisting of hominy, beans, seasoned meats, and vegetables. Each family has its unique version, leading to delightful variations. One undeniable fact: there is no Cape Verdean who doesn't appreciate Katxupa (\"Cachupa\") \u2014 whether for breakfast, lunch, dinner, or any time, anywhere.</p>"},{"location":"#why_katxupa","title":"Why Katxupa","text":"<p>For starters, the \"K\" in Katxupa stands for Kotlin, which was the primary inspiration for this library. Drawing from the functional programming paradigm of Kotlin and its concise yet expressive syntax, Katxupa aims to bring similar benefits to Typescript and JavaScript developers.</p>"},{"location":"#what_makes_katxupa_special","title":"What Makes Katxupa Special?","text":"<ul> <li> <p>Functional Delight: Katxupa introduces functional programming concepts to enhance your code's expressiveness and clarity.</p> </li> <li> <p>Kotlin-Inspired Goodness: Leveraging lessons learned from Kotlin, Katxupa provides utilities and extensions that streamline your workflow.</p> </li> <li> <p>Boosted Productivity: Enjoy a more productive development experience with Katxupa's utility classes, sequences, durations, and more.</p> </li> <li> <p>Developer Happiness: Inspired by the joy of coding in Kotlin, Katxupa seeks to bring happiness to your TypeScript and JavaScript projects.</p> </li> </ul>"},{"location":"#key_features","title":"Key Features","text":"<ul> <li> <p>Scope Functions: Kotlin-like scope functions, provides a set of functions to execute a block of code in the context of a given object: letIt, runIt, withIt, apply, and also.</p> </li> <li> <p>Collections Functions: Kotlin-like functions for Arrays, Maps, and Sets: Apply concise and expressive operations on collections.</p> </li> <li> <p>Sequences: Lazy sequences with a Kotlin-esque feel, providing a convenient way to work with iterable data.</p> </li> <li> <p>Duration: A flexible and comprehensive time duration class with support for various units, offering better time handling.</p> </li> <li> <p>Optional: A type that represents an optional value, helping to avoid null or undefined-related issues.</p> </li> <li> <p>Result and Either: Functional constructs to handle success, errors, and alternate paths in a more expressive manner.</p> </li> <li> <p>Inspired by Cape Verde: Infused with the spirit of Cape Verde  and its cherished dish Katxupa, this library aims to add flavor to your coding experience.</p> </li> </ul>"},{"location":"#get_a_taste_of_katxupa","title":"Get a Taste of Katxupa","text":"<p>Explore the documentation and see how Katxupa can bring a delightful touch to your TypeScript and JavaScript projects. From functional programming utilities to time handling and result handling, Katxupa is here to make your coding journey more enjoyable.</p>"},{"location":"#installation","title":"Installation","text":"<p>This package is build up with simplicity in mind, brings no additional dependencies, and it's published in NPM https://www.npmjs.com/package/katxupa.</p> <p>It can be installed using your preferred package manager.</p>"},{"location":"#npm","title":"NPM","text":"Bash<pre><code>npm install katxupa\n</code></pre>"},{"location":"#pnpm","title":"PNPM","text":"Bash<pre><code>pnpm install katxupa\n</code></pre>"},{"location":"#yarn","title":"YARN","text":"Bash<pre><code>yarn add katxupa\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#scope_functions","title":"Scope Functions","text":"<p>Simply call any value with letIt, runIt, also or apply, and it'll be passed as the argument or the context of a scope function.</p> TypeScript<pre><code>const person = {name: \"Manuel\", email: \"ney.br.santos@gmail.com\", age: 35};\nperson.letIt(it =&gt; {\nconsole.log(`${it.name},`);\nit.age &lt; 30 ? console.log(\"A Young Man\") : console.log(\"An Old Man\");\nreturn it.age;\n}).also(it =&gt; {\nconsole.log(`Actual Age is ${it}`);\n});\n// Output:\n//      Manuel,\n//      An Old Man\n//      Actual Age is 35\n</code></pre> <p>It also supports the use of the new Optional Chaining Operator, bringing the logic of Kotlin's Null Safe Calls to the JavaScript world.</p> TypeScript<pre><code> const user = await this.userRepository.findOneBy({\nid: userId,\n});\nuser?.runIt(function() {\nthis.emailService.send(this.email, `${this.name} welcome to the Katxupa library`);\n});\n</code></pre> <p>You can execute a block of code only if a value is neither null nor undefined: TypeScript<pre><code>const data: string | null = await getData();\ndata?.also(it =&gt; console.log(`Already initialized: ${it}`)) ?? console.log(\"Still not initialized\");\n</code></pre> The above code is equivalent to: TypeScript<pre><code>if (data != null &amp;&amp; data != undefined)\nconsole.log(`Already initialized: ${str!}`);\nelse\nconsole.log(\"Still not initialized\");\n</code></pre></p> <p>The usage of takeIf &amp; takeUnless is a bit different. You can call any value with takeIf and it will return the caller instance if the predicate is true, or undefined if it's false (and vice versa when using takeUnless). TypeScript<pre><code>const account = await accountService.getAccount(id);\naccount.takeIf(it =&gt; {\nreturn addressBook.has(it.email);\n})?.also(it =&gt; {\nemailService.send(it.email, \"You are entitled for crypto airdrop\")\n}) ?? console.log(`Account with ${id} not found in the system`);\n</code></pre></p>"},{"location":"#null_safety","title":"Null Safety","text":"<ul> <li>Null-safety through Optional Chaining Operator for scope functions: TypeScript<pre><code>// Only run the code block if \"numberOrUndefined\" is defined \nconst numberOrUndefinedOrNull = await bitcoinService.getPrice();\nnumberOrUndefinedOrNull?.letIt((it) =&gt; {\nit++;\nit = it * 100;\nreturn it;\n});\n// Actually, there is no need to declare a variable\n(await bitcoinService.getPrice())\n?.letIt((it) =&gt; {\nit++;\nit = it * 100;\nreturn it;\n});\n</code></pre></li> <li>Optional wrapper for general purpose: TypeScript<pre><code>// Example 1\n// Get Usecase:\n//    1- Validate if user exists\n//    2- Through an HttpError if not \n//    3- Return the user object\nreturn optionalOf(user)\n.orElseThrow(() =&gt; new NotFoundError(\"User doesn't exist\"))\n.get();\n// Example 2\n// Delete Usecase:\n//    1- Validate if user exists\n//    2- Through an HttpError if not \n//    3-  Delete the user from the database asynchronously and await for the result\nawait Optional.of(user)\n.orElseThrow(() =&gt; new HttpError(409, \"User doesn't exist\"))\n.runAsync(() =&gt; this.userRepository.delete({id: userId}));\n// Example 3\n// Update usecase:\n//    1- Validate if user exists\n//    2- Through an HttpError if not\n//    3- If exists, merge the existing one with additional userData\n//    4- Call the user repository and save the updated user asyncronously, returning a promise\n//            \nreturn optionalOf(user)\n.orElseThrow(() =&gt; new HttpError(409, \"User doesn't exist\"))\n.map(user =&gt; {\nreturn {\n...user,\nuserData,\n};\n})\n.runAsync(user =&gt; this.userRepository.save(user));\n</code></pre></li> </ul>"},{"location":"#duration","title":"Duration","text":"<p>An easy, expressive and functional way of declaring a duration of time with support for various units (nanoseconds, microseconds, milliseconds, seconds, minutes, hours, and days).</p> TypeScript<pre><code>// Example 1\ndurationOf(1000)\n.toSeconds()\n.letIt(it =&gt; {\nconsole.log(`1000 milliseconds are the same as ${it} seconds`);\n});\n// Example 2\nconst oneYearInMinutes = (1).years().toHours().toMinutes();\nconsole.log(`1 year is approximately ${oneYearInMinutes} minutes.`);\n// Example 3\nconst duration = (1).years().add((6).months()).toString();\nconsole.log(duration); // Output: 548d 0h 0m 0s 0ns\n</code></pre>"},{"location":"#range","title":"Range","text":"<p>The <code>Range</code> class provides utility methods for working with numeric ranges.</p> TypeScript<pre><code>// Example 1: Creating a Numeric Range\nconst numericRange = Range.rangeTo(1, 5, 2);\nconsole.log(numericRange); // Output: [1, 3, 5]\n// Example 2: Creating a Numeric Range (Exclusive)\nconst numericRangeAlias = rangeUntil(1, 5, 2);\nconsole.log(numericRangeAlias); // Output: [1, 3, 5]\n// Example 3: Checking if a Value is in Range\nconst isInRange = Range.inRange(3, 1, 5);\nconsole.log(isInRange); // Output: true\n// Example 4: Range with chaining Operations \nrangeTo(1, 5, 2)\n.runIt(function () {\nconsole.log(`multiplying the following range of numbers: ${this}`);\nthis.map(it =&gt; it * 2)\n.forEach(it =&gt; console.log(it));\n});\n</code></pre>"},{"location":"#global_utility_functions","title":"Global Utility Functions","text":"<p>Global functions are the unsung heroes that transcend the boundaries of specific data types, providing a universal toolkit for developers. These functions, residing in the global scope, are the go-to tools when you need versatile and expressive solutions that operate seamlessly across various data structures.</p>"},{"location":"#meet_some_ingredients","title":"Meet some Ingredients","text":"<ul> <li>runIt(): The maestro orchestrating the symphony of functions, runIt calls a specified function block and presents its harmonious result.</li> <li>withIt(): The chameleon of functions, withIt transforms any object into the star of the show, letting it shine in a function block tailored just for them.</li> <li>listOf(): Assemble an immutable list of elements effortlessly with listOf. It's your go-to for creating collections in a concise and readable manner.</li> <li>mutableListOf(): When you need a dynamic collection that can evolve with your needs, turn to mutableListOf to create mutable lists with ease.</li> <li>optionalOf(): Embrace the power of optionals with optionalOf, a function that lets you gracefully handle scenarios with potentially absent values.</li> <li>durationOf(): Time is of the essence, and durationOf allows you to craft time durations with precision, making time manipulation a breeze.</li> <li>sequenceOf(): Elevate your iteration game with sequenceOf, creating lazy sequences that conserve resources and provide on-the-fly transformation capabilities.</li> <li>reducerOf(): Transform your data with reducerOf, a function designed for building reducers that streamline complex state transformations in a functional paradigm.</li> <li>rangeTo(): Define ranges effortlessly with rangeTo, a function simplifying the creation of numeric ranges for iteration or data selection.</li> <li>ok(): Indicate success with confidence using ok. This function constructs an \"ok\" result, signaling that a task or operation was completed successfully.</li> <li>error(): Handle errors gracefully with error. This function constructs an error result, encapsulating details about the failure and allowing for structured error handling.</li> </ul> <p>These are just a smell of the utility this library brings to the table. Please, check the complete list in the Global Functions section.</p>"},{"location":"#type_extension_functions","title":"Type Extension Functions","text":"<p>In JavaScript, where each data type carries its own set of behaviors, type extension functions emerge as the virtuosos of customization. These functions enrich your interactions with core data types, injecting them with new capabilities, being functional or utilities, and streamlining common operations.</p> Type Utilities Object Extensions Extensions redefine how you interact with objects, enabling fluid and expressive operations tailored to your needs. Number Extensions Brings a consistent, functional and powerful approach to numeric operations String Extensions Give your strings a makeover with extensions that redefine the way you manipulate text. Boolean Extensions Functions like letIt, also, runIt, apply, takeIf, and takeUnless introduce a consistent and expressive way to handle boolean values."},{"location":"array/","title":"Array","text":"Markdown<pre><code>---\nid: array\ntitle: Array Component\nsidebar_label: Array\n---\n## Introduction\nThe Array component in the Katxupa library provides additional utility functions for working with arrays.\n\n### Installation\nTo use the Array component, you can include it in your project:\n\n```bash\nnpm install katxupa\n</code></pre>"},{"location":"array/#usage","title":"Usage","text":""},{"location":"array/#listof","title":"listOf","text":"<p>Creates an immutable list from the provided elements.</p> JavaScript<pre><code>const list = listOf(1, 2, 3);\n// list is [1, 2, 3]\n</code></pre>"},{"location":"array/#mutablelistof","title":"mutableListOf","text":"<p>Creates a mutable list from the provided elements.</p> JavaScript<pre><code>const mutableList = mutableListOf(1, 2, 3);\n// mutableList is [1, 2, 3]\n</code></pre>"},{"location":"array/#emptylist","title":"emptyList","text":"<p>Creates an empty list.</p> JavaScript<pre><code>const empty = emptyList();\n// empty is []\n</code></pre>"},{"location":"array/#associatewith","title":"associateWith","text":"<p>Associates each element with a key-value pair based on the provided selectors.</p> JavaScript<pre><code>const elements = [\n{ id: 1, value: 'a' },\n{ id: 2, value: 'b' },\n];\nconst keyValuePairs = elements.associateWith(\n(element) =&gt; element.id,\n(element) =&gt; element.value\n);\n// keyValuePairs is { '1': 'a', '2': 'b' }\n</code></pre>"},{"location":"array/#mapindexed","title":"mapIndexed","text":"<p>Maps each element to a new value using the provided transformation function.</p> JavaScript<pre><code>const numbers = [1, 2, 3];\nconst squaredNumbers = numbers.mapIndexed((num, index) =&gt; num * num + index);\n// squaredNumbers is [1, 5, 11]\n</code></pre>"},{"location":"array/#sortdescending","title":"sortDescending","text":"<p>Sorts the collection in descending order.</p> JavaScript<pre><code>const numbers = [3, 1, 4, 1, 5, 9, 2];\nconst sortedNumbers = numbers.sortDescending();\n// sortedNumbers is [9, 5, 4, 3, 2, 1, 1]\n</code></pre>"},{"location":"array/#sortby","title":"sortBy","text":"<p>Sorts the collection using the provided comparator function.</p> JavaScript<pre><code>const users = [\n{ name: 'John', age: 30 },\n{ name: 'Alice', age: 25 },\n{ name: 'Bob', age: 35 },\n];\nconst sortedUsers = users.sortBy((a, b) =&gt; a.age - b.age);\n// sortedUsers is [{ name: 'Alice', age: 25 }, { name: 'John', age: 30 }, { name: 'Bob', age: 35 }]\n</code></pre>"},{"location":"array/#plus","title":"plus","text":"<p>Concatenates the collection with another array.</p> JavaScript<pre><code>const collection = [1, 2, 3];\nconst otherArray = [4, 5, 6];\nconst result = collection.plus(otherArray);\n// result is [1, 2, 3, 4, 5, 6]\n</code></pre>"},{"location":"array/#minus","title":"minus","text":"<p>Removes elements from the collection that are present in another array.</p> JavaScript<pre><code>const collection = [1, 2, 3, 4, 5];\nconst elementsToRemove = [3, 5];\nconst result = collection.minus(elementsToRemove);\n// result is [1, 2, 4]\n</code></pre>"},{"location":"array/#minusassign","title":"minusAssign","text":"<p>Removes elements from the collection that are present in another array (mutates the collection).</p> JavaScript<pre><code>const collection = [1, 2, 3, 4, 5];\nconst elementsToRemove = [3, 5];\ncollection.minusAssign(elementsToRemove);\n// collection is now [1, 2, 4]\n</code></pre>"},{"location":"array/#plusassign","title":"plusAssign","text":"<p>Appends elements from another array to the collection (mutates the collection).</p> JavaScript<pre><code>const collection = [1, 2, 3];\nconst additionalElements = [4, 5, 6];\ncollection.plusAssign(additionalElements);\n// collection is now [1, 2, 3, 4, 5, 6]\n</code></pre>"},{"location":"array/#count","title":"count","text":"<p>Returns the number of elements in the collection.</p> JavaScript<pre><code>const collection = [1, 2, 3, 4, 5];\nconst count = collection.count();\n// count is 5\n</code></pre>"},{"location":"array/#removeall","title":"removeAll","text":"<p>Removes elements from the collection based on a predicate or a collection of elements.</p> JavaScript<pre><code>const collection = [1, 2, 3, 4, 5];\nconst elementsToRemove = [3, 5];\nconst result = collection.removeAll(elementsToRemove);\n// result is [1, 2, 4]\n</code></pre>"},{"location":"array/#retainall","title":"retainAll","text":"<p>Retains only the elements in the collection that are present in another array.</p> JavaScript<pre><code>const collection = [1, 2, 3, 4, 5];\nconst elementsToRetain = [3, 5];\nconst result = collection.retainAll(elementsToRetain);\n// result is [3, 5]\n</code></pre>"},{"location":"array/#last","title":"last","text":"<p>Returns the last element in the collection.</p> JavaScript<pre><code>const collection = [1, 2, 3];\nconst lastElement = collection.last();\n// lastElement is 3\n</code></pre>"},{"location":"array/#getorelse","title":"getOrElse","text":"<p>Gets the element at the specified index or provides a default value if the index is out of bounds.</p> JavaScript<pre><code>const collection = [1, 2, 3, 4, 5];\nconst element = collection.getOrElse(2, () =&gt; 10);\n// element is 3\n</code></pre>"},{"location":"array/#getorempty","title":"getOrEmpty","text":"<p>Gets an optional containing the element at the specified index.</p> JavaScript<pre><code>const collection = [1, 2, 3, 4, 5];\nconst optionalElement = collection.getOrEmpty(2);\n// optionalElement contains the value Optional.of(3)\n</code></pre>"},{"location":"array/#shuffle","title":"shuffle","text":"<p>Shuffles the elements in the collection randomly.</p> JavaScript<pre><code>const collection = [1, 2, 3, 4, 5];\ncollection.shuffle();\n// collection is now shuffled randomly, e.g., [3, 1, 5, 2, 4]\n</code></pre>"},{"location":"array/#api_reference","title":"API Reference","text":""},{"location":"array/#methods","title":"Methods","text":"<ul> <li>associateWith</li> <li>mapIndexed</li> <li>sortDescending</li> <li>sortBy</li> <li>plus</li> <li>minus</li> <li>minusAssign</li> <li>plusAssign</li> <li>count</li> <li>removeAll</li> <li>retainAll</li> <li>last</li> <li>getOrElse</li> <li>getOrEmpty</li> <li>shuffle</li> </ul>"},{"location":"array/#associatewith_1","title":"associateWith","text":"<p>Associates each element with a key-value pair based on the provided selectors.</p>"},{"location":"array/#parameters","title":"Parameters","text":"<ul> <li><code>keySelector: (element: T) =&gt; K</code> - The function to extract keys from elements.</li> <li><code>valueSelector: (element: T) =&gt; V</code> - The function to extract values from elements.</li> </ul>"},{"location":"array/#returns","title":"Returns","text":"<p>A record associating keys with their corresponding values.</p>"},{"location":"array/#example","title":"Example","text":"JavaScript<pre><code>const elements = [\n{ id: 1, value: 'a' },\n{ id: 2, value: 'b' },\n];\nconst keyValuePairs = elements.associateWith(\n(element) =&gt; element.id,\n(element) =&gt; element.value\n);\n// keyValuePairs is { '1': 'a', '2': 'b' }\n</code></pre>"},{"location":"array/#mapindexed_1","title":"mapIndexed","text":"<p>Maps each element to a new value using the provided transformation function.</p>"},{"location":"array/#parameters_1","title":"Parameters","text":"<ul> <li><code>transform: (element: T, index: number) =&gt; U</code> - The function to transform each element.</li> </ul>"},{"location":"array/#returns_1","title":"Returns","text":"<p>A readonly array containing the transformed elements.</p>"},{"location":"array/#example_1","title":"Example","text":"JavaScript<pre><code>const numbers = [1, 2, 3];\nconst squaredNumbers = numbers.mapIndexed((num, index) =&gt; num * num + index);\n// squaredNumbers is [1, 5, 11]\n</code></pre>"},{"location":"array/#sortdescending_1","title":"sortDescending","text":"<p>Sorts the collection in descending order.</p>"},{"location":"array/#returns_2","title":"Returns","text":"<p>A reference to the sorted array.</p>"},{"location":"array/#example_2","title":"Example","text":"JavaScript<pre><code>const numbers = [3, 1, 4, 1, 5, 9, 2];\nnumbers.sortDescending();\n// numbers is now [9, 5, 4, 3, 2, 1, 1]\n</code></pre>"},{"location":"array/#sortby_1","title":"sortBy","text":"<p>Sorts the collection using the provided comparator function.</p>"},{"location":"array/#parameters_2","title":"Parameters","text":"<ul> <li><code>comparator: (a: T, b: T) =&gt; number</code> - The function to compare elements.</li> </ul>"},{"location":"array/#returns_3","title":"Returns","text":"<p>A reference to the sorted array.</p>"},{"location":"array/#example_3","title":"Example","text":"JavaScript<pre><code>const users = [\n{ name: 'John', age: 30 },\n{ name: 'Alice', age: 25 },\n{ name: 'Bob', age: 35 },\n];\nusers.sortBy((a, b) =&gt; a.age - b.age);\n// users is now sorted by age: [{ name: 'Alice', age: 25 }, { name: 'John', age: 30 }, { name: 'Bob', age: 35 }]\n</code></pre>"},{"location":"array/#plus_1","title":"plus","text":"<p>Concatenates the collection with another array.</p>"},{"location":"array/#parameters_3","title":"Parameters","text":"<ul> <li><code>other: T[]</code> - The array to concatenate with the current collection.</li> </ul>"},{"location":"array/#returns_4","title":"Returns","text":"<p>A new array containing elements from both the current collection and the provided array.</p>"},{"location":"array/#example_4","title":"Example","text":"JavaScript<pre><code>const collection = [1, 2, 3];\nconst otherArray = [4, 5, 6];\nconst result = collection.plus(otherArray);\n// result is [1, 2, 3, 4, 5, 6]\n</code></pre>"},{"location":"array/#minus_1","title":"minus","text":"<p>Removes elements from the collection that are present in another array.</p>"},{"location":"array/#parameters_4","title":"Parameters","text":"<ul> <li><code>other: T[]</code> - The array containing elements to be removed from the current collection.</li> </ul>"},{"location":"array/#returns_5","title":"Returns","text":"<p>A new array with elements not present in the provided array.</p>"},{"location":"array/#example_5","title":"Example","text":"JavaScript<pre><code>const collection = [1, 2, 3, 4, 5];\nconst elementsToRemove = [3, 5];\nconst result = collection.minus(elementsToRemove);\n// result is [1, 2, 4]\n</code></pre>"},{"location":"array/#minusassign_1","title":"minusAssign","text":"<p>Removes elements from the collection that are present in another array (mutates the collection).</p>"},{"location":"array/#parameters_5","title":"Parameters","text":"<ul> <li><code>collection: T[]</code> - The array containing elements to be removed from the current collection.</li> </ul>"},{"location":"array/#returns_6","title":"Returns","text":"<p>A reference to the affected array.</p>"},{"location":"array/#example_6","title":"Example","text":"JavaScript<pre><code>const collection = [1, 2, 3, 4, 5];\nconst elementsToRemove = [3, 5];\ncollection.minusAssign(elementsToRemove);\n// collection is now [1, 2, 4]\n</code></pre>"},{"location":"array/#plusassign_1","title":"plusAssign","text":"<p>Appends elements from another array to the collection (mutates the collection).</p>"},{"location":"array/#parameters_6","title":"Parameters","text":"<ul> <li><code>other: T[]</code> - The array containing elements to be added to the current collection.</li> </ul>"},{"location":"array/#returns_7","title":"Returns","text":"<p>A reference to the affected array.</p>"},{"location":"array/#example_7","title":"Example","text":"JavaScript<pre><code>const collection = [1, 2, 3];\nconst additionalElements = [4, 5, 6];\ncollection.plusAssign(additionalElements);\n// collection is now [1, 2, 3, 4, 5, 6]\n</code></pre>"},{"location":"array/#count_1","title":"count","text":"<p>Returns the number of elements in the collection.</p>"},{"location":"array/#returns_8","title":"Returns","text":"<p>The number of elements in the collection.</p>"},{"location":"array/#example_8","title":"Example","text":"JavaScript<pre><code>const collection = [1, 2, 3, 4, 5];\nconst count = collection.count();\n// count is 5\n</code></pre>"},{"location":"array/#removeall_1","title":"removeAll","text":"<p>Removes elements from the collection based on a predicate or a collection of elements.</p>"},{"location":"array/#parameters_7","title":"Parameters","text":"<ul> <li><code>predicate: ((item: T) =&gt; boolean) | T[]</code> - The predicate function or collection of elements to remove.</li> </ul>"},{"location":"array/#returns_9","title":"Returns","text":"<p>A new array with elements removed based on the provided predicate or collection.</p>"},{"location":"array/#example_9","title":"Example","text":"JavaScript<pre><code>const collection = [1, 2, 3, 4, 5];\nconst elementsToRemove = [3, 5];\nconst result = collection.removeAll(elementsToRemove);\n// result is [1, 2, 4]\n</code></pre>"},{"location":"array/#retainall_1","title":"retainAll","text":"<p>Retains only the elements in the collection that are present in another array.</p>"},{"location":"array/#parameters_8","title":"Parameters","text":"<ul> <li><code>predicate: ((item: T) =&gt; boolean) | T[]</code> - The predicate function or collection of elements to retain.</li> </ul>"},{"location":"array/#returns_10","title":"Returns","text":"<p>A new array containing only the elements that satisfy the provided predicate or are present in the provided collection.</p>"},{"location":"array/#example_10","title":"Example","text":"JavaScript<pre><code>const collection = [1, 2, 3, 4, 5];\nconst elementsToRetain = [3, 5];\nconst result = collection.retainAll(elementsToRetain);\n// result is [3, 5]\n</code></pre>"},{"location":"array/#last_1","title":"last","text":"<p>Returns the last element in the collection.</p>"},{"location":"array/#returns_11","title":"Returns","text":"<p>The last element in the collection.</p>"},{"location":"array/#throws","title":"Throws","text":"<ul> <li><code>NoSuchElementError</code> - If the collection is empty.</li> </ul>"},{"location":"array/#example_11","title":"Example","text":"JavaScript<pre><code>const collection = [1, 2, 3];\nconst lastElement = collection.last();\n// lastElement is 3\n</code></pre>"},{"location":"array/#getorelse_1","title":"getOrElse","text":"<p>Gets the element at the specified index or provides a default value if the index is out of bounds.</p>"},{"location":"array/#parameters_9","title":"Parameters","text":"<ul> <li><code>index: number</code> - The index of the element to retrieve.</li> <li><code>defaultValueProvider: () =&gt; T</code> - A function providing the default value.</li> </ul>"},{"location":"array/#returns_12","title":"Returns","text":"<p>The element at the specified index or the default value if the index is out of bounds.</p>"},{"location":"array/#example_12","title":"Example","text":"JavaScript<pre><code>const collection = [1, 2, 3, 4, 5];\nconst element = collection.getOrElse(2, () =&gt; 10);\n// element is 3\n</code></pre>"},{"location":"array/#getorempty_1","title":"getOrEmpty","text":"<p>Gets an optional containing the element at the specified index.</p>"},{"location":"array/#parameters_10","title":"Parameters","text":"<ul> <li><code>index: number</code> - The index of the element.</li> </ul>"},{"location":"array/#returns_13","title":"Returns","text":"<p>An optional containing the element if it exists, otherwise an empty optional.</p>"},{"location":"array/#example_13","title":"Example","text":"JavaScript<pre><code>const collection = [1, 2, 3, 4, 5];\nconst optionalElement = collection.getOrEmpty(2);\n// optionalElement contains the value Optional.of(3)\n</code></pre>"},{"location":"array/#shuffle_1","title":"shuffle","text":"<p>Shuffles the elements in the collection randomly.</p>"},{"location":"array/#returns_14","title":"Returns","text":"<p>A reference to the affected array.</p>"},{"location":"array/#example_14","title":"Example","text":"<p>```javascript const collection = [1, 2, 3, 4, 5]; collection.shuffle(); // collection is now shuffled randomly, e.g., [3, 1, 5, 2, 4]</p>"},{"location":"index2/","title":"Katxupa","text":"<p>Delicious Dish for Typescript and JavaScript projects.</p> <p>In Cape Verde we have a saying:</p> <p>\"Put a person to work in the field and serve them anything other than Katxupa for breakfast, and you'll notice a decline in productivity and motivation. Therefore, give them Katxupa and spice it up on the side.\"</p> <p>Just as \"Katxupa\" is an essential part of Cape Verdean culture, this library brings functional elements to enhance your productivity and developer happiness. So, consume (use) it!</p> <p>Katxupa, Cape Verde\u2019s national dish, is a flavorful stew consisting of hominy, beans, seasoned meats, and vegetables. Each family has its unique version, leading to delightful variations. One undeniable fact: there is no Cape Verdean who doesn't appreciate Katxupa (\"Cachupa\") \u2014 whether for breakfast, lunch, dinner, or any time, anywhere.</p>"},{"location":"index2/#why_katxupa","title":"Why Katxupa","text":"<p>For starters, the \"K\" in Katxupa stands for Kotlin, which was the primary inspiration for this library. Drawing from the functional programming paradigm of Kotlin and its concise yet expressive syntax, Katxupa aims to bring similar benefits to Typescript and JavaScript developers.</p>"},{"location":"index2/#what_makes_katxupa_special","title":"What Makes Katxupa Special?","text":"<ul> <li> <p>Functional Delight: Katxupa introduces functional programming concepts to enhance your code's expressiveness and clarity.</p> </li> <li> <p>Kotlin-Inspired Goodness: Leveraging lessons learned from Kotlin, Katxupa provides utilities and extensions that streamline your workflow.</p> </li> <li> <p>Boosted Productivity: Enjoy a more productive development experience with Katxupa's utility classes, sequences, durations, and more.</p> </li> <li> <p>Developer Happiness: Inspired by the joy of coding in Kotlin, Katxupa seeks to bring happiness to your TypeScript and JavaScript projects.</p> </li> </ul>"},{"location":"index2/#key_features","title":"Key Features","text":"<ul> <li> <p>Scope Functions: Kotlin-like scope functions, provides a set of functions to execute a block of code in the context of a given object: letIt, runIt, withIt, apply, and also.</p> </li> <li> <p>Collections Functions: Kotlin-like functions for Arrays, Maps, and Sets: Apply concise and expressive operations on collections.</p> </li> <li> <p>Sequences: Lazy sequences with a Kotlin-esque feel, providing a convenient way to work with iterable data.</p> </li> <li> <p>Duration: A flexible and comprehensive time duration class with support for various units, offering better time handling.</p> </li> <li> <p>Optional: A type that represents an optional value, helping to avoid null or undefined-related issues.</p> </li> <li> <p>Result and Either: Functional constructs to handle success, errors, and alternate paths in a more expressive manner.</p> </li> <li> <p>Inspired by Cape Verde: Infused with the spirit of Cape Verde  and its cherished dish Katxupa, this library aims to add flavor to your coding experience.</p> </li> </ul>"},{"location":"index2/#get_a_taste_of_katxupa","title":"Get a Taste of Katxupa","text":"<p>Explore the documentation and see how Katxupa can bring a delightful touch to your TypeScript and JavaScript projects. From functional programming utilities to time handling and result handling, Katxupa is here to make your coding journey more enjoyable.</p>"},{"location":"scope/","title":"Scope Functions","text":""},{"location":"scope/#scope_functions","title":"Scope Functions","text":"<p>The Katxupa library contains several functions whose sole purpose is to execute a block of code within the context of an object.  When you call such a function on an object with a lambda expression provided, it forms a temporary scope. In this scope,  you can access the object through it or in some cases this. Such functions are called scope functions. </p> <p>There are five of them: letIt, runIt, withIt, applyIt, and alsoIt.</p> <p>Basically, these functions all perform the same action: execute a block of code on an object. What's different is how this  object becomes available inside the block and what the result of the whole expression is.</p> <p>Here's a typical example of how to use a scope function: TypeScript<pre><code>({name: \"Manuel\", age: 36})\n.letIt(it =&gt; {\nconsole.log(it);\nit.age++;\nconsole.log(it);\n});\n</code></pre> If you write the same without letIt, you'll have to introduce a new variable and repeat its name whenever you use it. TypeScript<pre><code>const user = {name: \"Manuel\", age: 36};\nconsole.log(user);\nuser.age++;\nconsole.log(user);\n</code></pre></p> <p>Scope functions don't introduce any new technical capabilities, but they can make your code more concise and readable.</p> <p>Due to the many similarities between scope functions, choosing the right one for your use case can be tricky.  The choice mainly depends on your intent and the consistency of use in your project. Below, we provide detailed descriptions  of the differences between scope functions and their conventions.</p>"},{"location":"scope/#function_selection","title":"Function selection","text":"<p>To help you choose the right scope function for your purpose, we provide this table that summarizes the key differences between them.</p> Function Object Reference Return Value Is extension function letIt it Lambda Result Yes runIt this Lambda Result Yes runIt - Lambda Result No: called without the context object withIt this Lambda Result No: takes the context object as an argument. applyIt this Context Object Yes alsoIt it Context Object Yes <p>Note that letIt &amp; alsoIt can be called with standard lambda/arrow functions, but because JavaScript arrow functions don't  have an own this context, runIt &amp; applyIt have to be called with standard functions.</p> <p>Detailed information about these functions is provided in the dedicated sections below.</p> <p>Here is a short guide for choosing scope functions depending on the intended purpose: * Executing a lambda on non-nullable objects: letIt * Introducing an expression as a variable in local scope: letIt * Object configuration: applyIt * Object configuration and computing the result: runIt *  Running statements where an expression is required: non-extension runIt * Additional effects: alsoIt * Grouping function calls on an object: withIt</p> <p>The use cases of different scope functions overlap, so you can choose which functions to use based on the specific  conventions used in your project or team.</p> <p>Although scope functions can make your code more concise, avoid overusing them: it can make your code hard to read and  lead to errors. We also recommend that you avoid nesting scope functions and be careful when chaining them because it's  easy to get confused about the current context object and value of this or it.</p>"},{"location":"scope/#distinctions","title":"Distinctions","text":"<p>Because scope functions are similar in nature, it's important to understand the differences between them. There are two  main differences between each scope function:</p> <ul> <li>The way they refer to the context object.</li> <li>Their return value.</li> </ul>"},{"location":"scope/#context_object_this_or_it","title":"Context object: this or it","text":"<p>Inside the lambda passed to a scope function, the context object is available by a short reference instead of its actual name.  Each scope function uses one of two ways to reference the context object: as a function receiver (this) or as a lambda argument (it).  Both provide the same capabilities, so we describe the pros and cons of each for different use cases and provide recommendations for their use.</p> TypeScript<pre><code>function main() {\nconst str = \"Hello\"\n// this\nstr.runIt(function () {\nconsole.log(`The string's length: ${this.length}`)\n} );\n// it\nstr.letIt(it =&gt; {\nconsole.log(`The string's length: ${it.length}`)\n})\n}\n</code></pre>"},{"location":"scope/#functions","title":"Functions","text":"<p>To help you choose the right scope function for your use case, we describe them in detail and provide recommendations for use.  Technically, scope functions are interchangeable in many cases, so the examples show conventions for using them.</p>"},{"location":"scope/#letit","title":"letIt","text":"<ul> <li>The context object is available as an argument (it).</li> <li>The return value is the lambda result.</li> </ul> <p>letIt can be used to invoke one or more functions on results of call chains. TypeScript<pre><code>const data: Array&lt;number&gt; | null = await idsFromFile();\nconst str = data?.letIt(it =&gt; convertToString(it)) ?? \"empty\";\n</code></pre></p>"},{"location":"scope/#withit","title":"withIt","text":"<ul> <li>The context object is available as a receiver (this).</li> <li>The return value is the lambda result.</li> </ul> <p>As withIt is not an extension function: the context object is passed as an argument, but inside the lambda, it's available as a receiver (this).</p> <p>We recommend using withIt for calling functions on the context object when you don't need to use the returned result.  In code, with can be read as \"with this object, do the following.\"</p> TypeScript<pre><code>const numbers = mutableListOf(\"one\", \"two\", \"three\");\nwithIt(numbers, function () {\nconsole.log(`'withIt' is called with argument ${this}`);\nconsole.log(`It contains ${this.length} elements`);\n});\n</code></pre> <p>You can also use withIt to introduce a helper object whose properties or functions are used for calculating a value. TypeScript<pre><code>const numbers = mutableListOf&lt;string&gt;(\"one\", \"two\", \"three\");\nconst firstAndLast = withIt(numbers, function () {\nreturn `The first element is ${this.first()}, the last element is ${this.last()}`\n});\nconsole.debug(firstAndLast);\n</code></pre></p>"},{"location":"scope/#runit","title":"runIt","text":"<ul> <li>The context object is available as a receiver (this).</li> <li>The return value is the lambda result.</li> </ul> <p>runIt does the same as withIt but it is implemented as an extension function. So like letIt, you can call it on the context object using dot notation.</p> <p>runIt is useful when your lambda function both initializes objects and computes the return value.</p> TypeScript<pre><code>const service = new MultiportService(\"https://api.example.com/data\", 80)\nconst result = service.runIt(function () {\nthis.port = 8080;\nconst result = this.query(prepareRequest());\nconsole.debug(`Request sent to port ${this.port}\"`);\nreturn result;\n});\n// the same code written with letIt() function:\nconst letResult = service.letIt(it =&gt; {\nit.port = 8080;\nconst result = it.query(prepareRequest());\nconsole.debug(`Request sent to port ${it.port}\"`);\nreturn result;\n});\n</code></pre> <p>You can also invoke runIt as a non-extension function. The non-extension variant of runIt has no context object, but it still returns the lambda result.  Non-extension run lets you execute a block of several statements where an expression is required.  In code, non-extension runIt can be read as \"run the code block and compute the result.\"</p> TypeScript<pre><code>const hexNumberRegex = runIt(() =&gt; {\nconst digits = \"0-9\"\nconst hexDigits = \"A-Fa-f\"\nconst sign = \"+-\"\nreturn  new RegExp(`[${sign}]?[${digits}${hexDigits}]+`, \"g\");\n});\nlet match;\nwhile ((match = hexNumberRegex.exec(\"+123 -FFFF !%*&amp; 88 XYZ\")) !== null) {\nconsole.log(match[0]);\n}\n</code></pre>"},{"location":"scope/#applyit","title":"applyIt","text":"<ul> <li>The context object is available as a receiver (this).</li> <li>The return value is the object itself.</li> </ul> <p>As applyIt returns the context object itself, we recommend that you use it for code blocks that don't return a value and  that mainly operate on the members of the receiver object. The most common use case for applyIt is for object configuration.  Such calls can be read as \"apply the following assignments to the object.\"</p> <p>TypeScript<pre><code>const manuel = {name: \"Manuel\", age: 36};\nmanuel.applyIt(function () {\nthis.name = \"Manuel Santos\";\nthis.age++;\n(this as any)[\"country\"] = \"Portugal\";\n});\nconsole.log(manuel)\n</code></pre> Another use case for applyIt is to include applyIt in multiple call chains for more complex processing.</p>"},{"location":"scope/#alsoit","title":"alsoIt","text":"<ul> <li>The context object is available as an argument (it).</li> <li>The return value is the object itself.</li> </ul> <p>alsoIt is useful for performing some actions that take the context object as an argument. Use alsoIt for actions that need a reference to the object rather than its properties and functions, or when you don't want to shadow the this reference from an outer scope.</p> <p>When you see also in code, you can read it as \"and also do the following with the object.\"</p> TypeScript<pre><code>const numbers = mutableListOf&lt;string&gt;(\"one\", \"two\", \"three\");\nnumbers\n.alsoIt(it =&gt; console.log(`The list elements before adding new one: ${it}`))\n.push(\"four\");\n</code></pre>"},{"location":"scope/#takeif_and_takeunless","title":"takeIf and takeUnless","text":"<p>In addition to scope functions, the Katxupa standard library contains the functions takeIf and takeUnless.  These functions let you embed checks of an object's state in call chains.</p> <p>When called on an object along with a predicate, takeIf returns this object if it satisfies the given predicate.  Otherwise, it returns undefined. So, takeIf is a filtering function for a single object.</p> <p>takeUnless has the opposite logic of takeIf. When called on an object along with a predicate, takeUnless returns  undefined if it satisfies the given predicate. Otherwise, it returns the object.</p> <p>When using takeIf or takeUnless, the object is available as a lambda argument (it).</p> TypeScript<pre><code>const number: number = Math.floor(Math.random() * 100);\nconst evenOrNull = number.takeIf(it =&gt;  it % 2 == 0);\nconst oddOrNull = number.takeUnless(it =&gt; it % 2 == 0);\nconsole.log(`even: ${evenOrNull}, odd: ${oddOrNull}`);\n</code></pre> <p>When chaining other functions after takeIf and takeUnless, don't forget to perform a null check or use a safe call (?.) because their return value is nullable.</p> TypeScript<pre><code>const str = \"Hello\";\nconst caps = str.takeIf(it =&gt; it.length &gt; 0)?.toUpperCase();\n//const caps = str.takeIf(it =&gt; it.length &gt; 0).toUpperCase() //compilation error\nconsole.debug(caps);\n</code></pre> <p>takeIf and takeUnless are especially useful in combination with scope functions. For example, you can chain  takeIf and takeUnless with letIt to runIt a code block on objects that match the given predicate. To do this,  call takeIf on the object and then call let with a safe call (?). For objects that don't match the predicate, takeIf  returns undefined and letIt isn't invoked.</p> TypeScript<pre><code>function displaySubstringPosition(input: string, sub: string) {\ninput.indexOf(sub)\n.takeIf(it =&gt; it &gt;= 0)\n?.letIt(it =&gt; {\nconsole.log(`The substring ${sub} is found in ${input}.`)\nconsole.log(`Its start position is ${it}.`)\n});\n}\ndisplaySubstringPosition(\"010000011\", \"11\");\ndisplaySubstringPosition(\"010000011\", \"12\");\n// Output:\n//  The substring 11 is found in 010000011.\n//  Its start position is 7.\n</code></pre>"}]}